# 1. 目的（Purpose）

このアプリは、WT9011DCL IMUセンサーから得られる加速度・角速度・姿勢データを活用し、バットのスイングスピードや角度、インパクトのタイミングなどを可視化することを目的とする。主に野球の練習時のパフォーマンス分析やトレーニング改善を支援する。

# 2. 対象ユーザー（Target Users）

* 少年野球・学生野球の選手と指導者
* 趣味でバッティングを楽しむ一般ユーザー

# 3 . 利用機材（Hardware）

* IMUセンサー WT9011DCL（BLE接続）
* Android端末

# 4. 主要機能（Main Features）

## センサー連携

* BLEスキャン＆接続
* データ受信（加速度・角速度・姿勢）
* 接続状態のUI表示

## スイング計測

* スイング開始・終了の自動検出（閾値ベース）
* 最大スイングスピードの表示（角速度 or 加速度ベース）
    * バット長（有効半径）をユーザー設定項目として入力可能にする
    * 角速度から線速度を算出する際、設定値を反映して補正する
* スイングデータの記録＆リスト表示

### スイングスピード算出モデル（Angular Velocity–Based Calculation）

#### 基本式

スイングスピードは、センサーが取得した角速度ベクトルの大きさ（|ω|）と、回転軸から先端点までの有効半径（R）を用いて求める：

```
スイングスピード（m/s） = |ω_max| × R
```

* ω_max：スイング中の角速度の最大値 [rad/s]
* R：回転軸から先端（またはスイートスポット）までの距離 [m]

#### 入力パラメータ

* ユーザーまたはプリセット設定により次を指定：
    * バット全長（L）
    * 手元オフセット距離（d_hand）
    * スイートスポット位置（d_sweet）

これにより有効半径は以下のように求める：

```
R = d_sweet − d_hand
```

#### 補正・近似

実際のスイングでは手元や体幹の並進運動も寄与するが、WT9011DCL単体ではそれを直接取得できない。初期バージョンでは以下の近似を採用する：

```
スイングスピード実効値 ≈ (|ω_max| × R) × 1.1
```

補正係数1.1は、体幹や前腕の並進運動による寄与を統計的に補う経験的値とする（後日キャリブレーションにより調整可能）。

#### 出力例

* 最大角速度：12.5 rad/s
* 有効半径 R = 0.78 m
* → スイングスピード = 12.5 × 0.78 × 1.1 ≈ 10.7 m/s

### d_hand（手元オフセット距離）の定義と補正に関する補足

* 定義
    * d_hand は、センサー（WT9011DCL）を取り付けたノブ端から、上手（かみて）側の手の中心までの距離を指す。スイング中の回転中心がこの付近に存在すると仮定し、回転半径計算に反映する。
* 意義
    * 角速度から求める線速度では、回転軸位置のずれがそのまま速度誤差に直結する。センサーがノブ端にあり、回転中心がその上方にあるため、d_hand を考慮することで過大評価を防ぐ。
* 計算関係
    * R = d_sweet − d_hand
    * ここで、
        * L = バット全長
        * d_hand = ノブ端から手の回転中心までの距離
        * d_sweet = ノブ端からスイートスポットまでの距離
* 実装に向けた考慮
    * 誤差1cmで速度が約1%変化するため、ユーザーがアプリ内で設定できるスライダーまたは数値入力項目として実装する

### WT9011DCL使用時のスイングスピード計算ロジック

####  センサー軸の定義（WT9011DCL公式資料参照）

WT9011DCLは以下の座標系を持つ：
* X軸（Roll）：左方向
* Y軸（Pitch）：前方向
* Z軸（Yaw）：上方向（自転軸）

このため、Z軸はバットの自転（ロール回転）に対応し、スイング面の回転は主にX軸およびY軸で表現される。

#### 姿勢を使用しない計算モデル

センサー取り付け方向が一定（Z軸がバット軸方向）であることを前提に、姿勢角（クォータニオンやオイラー角）を使用せず、角速度のX・Y成分のみを用いてスイングスピードを求める：

```
ω_perp = sqrt(ω_x^2 + ω_y^2)
```

スイングスピードは次式で計算される：

```
スイングスピード（m/s） = max(ω_perp) × R
```

ここで：

* ω_x, ω_y はセンサー出力（deg/s）をラジアン変換した値
* R = d_sweet − d_hand


####  特徴と前提

| 項目 | 内容 |
|------|------|
| 姿勢計算 | 不使用（センサー軸固定前提） |
| 使用軸 | X, Y軸の角速度成分のみ |
| 自転除去 | Z軸は使用しない（Yaw成分除外） |
| キャリブレーション | なし（装着方向が一定であることを前提） |
| 誤差要因 | センサーZ軸の傾き（5°で約0.4%の速度誤差） |

#### 擬似コード

```kotlin
val DEG2RAD = Math.PI.toFloat() / 180f
fun tipSpeedNoAtt(samples: List<Vec3>, R: Float, gain: Float = 1.0f): Float {
    var wmax = 0f
    for (wDeg in samples) {
        val wx = wDeg.x * DEG2RAD
        val wy = wDeg.y * DEG2RAD
        val wperp = kotlin.math.sqrt(wx*wx + wy*wy)
        if (wperp > wmax) wmax = wperp
    }
    return wmax * R * gain
}
```

### スイング検出ロジック（加速度主体＋ジャイロ併用）

#### 目的

振り終わりの惰性回転や戻し動作でジャイロが反応し続けても誤検出しないよう、**開始は加速度主体**、**終了は加速度＋ジャイロの両方で沈静化を確認**する。

#### 前処理

- サンプリング：200 Hz（WT9011DCL 設定）
- 単位：
  - 角速度：deg/s → rad/s
  - 加速度：g → m/s²（必要時）
- フィルタ：
  - 加速度：ローパス(30–40 Hz)でノイズ低減
  - 重力除去：センサー内姿勢(AHRS)の重力ベクトル **ĝ** を使い、
    `a_dyn = a_meas − ĝ·|g|`
  - スカラー量：`|a_dyn| = sqrt(ax² + ay² + az²)`

#### 主要指標

- `A(t) = |a_dyn(t)|`（動的加速度のノルム）
- `W⊥(t) = sqrt(ωx² + ωy²)`（バット自転(Z)を除いた回転成分；姿勢なし固定実装前提）
- スムージング：各指標に 15–25 ms 移動平均（3–5 サンプル中央値 → 5–7 サンプル平均）

#### 開始判定（Acceleration-driven）

1. `A(t)` が `start_threshold_A` を **T_rise** 以上連続で超過
   - 例：`start_threshold_A = 3.0–4.0 m/s²`、`T_rise = 20–30 ms`
2. 直近 **refractory_period** 内に開始確定がないこと
   - 例：`refractory_period = 200 ms`

→ 条件成立時点を **SwingStart** とする。

#### 終了判定（Hybrid guard）

以下の **両方** を満たしたとき **SwingEnd**：
1. `A(t)` が `end_threshold_A` 未満を **T_fall** 以上継続
   - 例：`end_threshold_A = 1.5–2.0 m/s²`、`T_fall = 40–60 ms`
2. `W⊥(t)` が `end_threshold_W` 未満を **T_fall** 以上継続
   - 例：`end_threshold_W = 2.5–3.5 rad/s`

> 開始は“押し込み（線加速）の鋭い立ち上がり”を捉えるため加速度を採用。
> 終了は“惰性回転”や“戻し”で `W⊥` が残っても、`A` と同時沈静化を要求して誤検出を回避。

#### 1スイング内の集計

- ピーク角速度：`W⊥_max = max_t W⊥(t)`（SwingStart–SwingEnd）
- 先端速度：`v_tip = W⊥_max × R`（R = d_sweet − d_hand）
- 参考値：`A_max = max_t A(t)`、期間、インパクト近傍時刻（`A(t)` 局所最大）

#### 推奨初期パラメータ（200 Hz向け）

| パラメータ | 初期値 | 備考 |
|---|---|---|
| start_threshold_A | 3.5 m/s² | 3.0–4.0で調整 |
| end_threshold_A | 1.8 m/s² | 1.5–2.0で調整 |
| end_threshold_W | 3.0 rad/s | 2.5–3.5で調整 |
| T_rise | 25 ms | 5サンプル相当 |
| T_fall | 50 ms | 10サンプル相当 |
| refractory_period | 200 ms | 二重検出防止 |

#### 擬似コード

```kotlin
if (!swinging) {
    if (A > startA && sustainedFor(T_rise) && timeSince(lastStart) > refractory) {
        swinging = true
        wPerpPeak = 0f
        swingStart = t
    }
} else {
    wPerpPeak = max(wPerpPeak, Wperp)
    val endAok = (A < endA).sustainedFor(T_fall)
    val endWok = (Wperp < endW).sustainedFor(T_fall)
    if (endAok && endWok) {
        swinging = false
        swingEnd = t
        val vtip = wPerpPeak * R
        saveSwing(vtip, swingStart, swingEnd, wPerpPeak)
        lastStart = swingStart
    }
}
```

## データ管理

* 計測履歴の一覧表示
    * 日時
    * スピード
    * 角度
    * ユーザー
        * 複数ユーザーの記録が1つのアプリで取れるものとする

## UI/UX

* スタート／ストップボタンによる操作
* シンプルで見やすいスイング分析UI
* 接続状況やバッテリー残量の表示（可能であれば）
* ユーザーおよびバットの切り替え

# 5. 非機能要件（Non-Functional Requirements）

* パフォーマンス
    * BLE接続時でもUIの操作が快適であること
* 安定性
    * 通信切断時のリカバリ処理があること
* 拡張性
    * 将来的に他のセンサーに対応するために、デバイス依存の部分とそうでない部分が切り離されていること
